=== tests/cases/conformance/types/literal/templateLiteralTypes1.ts ===
// Template types example from #12754

const createScopedActionType = <S extends string>(scope: S) => <T extends string>(type: T) => `${scope}/${type}` as `${S}/${T}`;
>createScopedActionType : Symbol(createScopedActionType, Decl(templateLiteralTypes1.ts, 2, 5))
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 2, 32))
>scope : Symbol(scope, Decl(templateLiteralTypes1.ts, 2, 50))
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 2, 32))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 2, 64))
>type : Symbol(type, Decl(templateLiteralTypes1.ts, 2, 82))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 2, 64))
>scope : Symbol(scope, Decl(templateLiteralTypes1.ts, 2, 50))
>type : Symbol(type, Decl(templateLiteralTypes1.ts, 2, 82))
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 2, 32))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 2, 64))

const createActionInMyScope = createScopedActionType("MyScope");  // <T extends string>(type: T) => `MyScope/${T}`
>createActionInMyScope : Symbol(createActionInMyScope, Decl(templateLiteralTypes1.ts, 3, 5))
>createScopedActionType : Symbol(createScopedActionType, Decl(templateLiteralTypes1.ts, 2, 5))

const MY_ACTION = createActionInMyScope("MY_ACTION");  // 'MyScope/MY_ACTION'
>MY_ACTION : Symbol(MY_ACTION, Decl(templateLiteralTypes1.ts, 4, 5))
>createActionInMyScope : Symbol(createActionInMyScope, Decl(templateLiteralTypes1.ts, 3, 5))

// Union types are distributed over template types

type EventName<S extends string> = `${S}Changed`;
>EventName : Symbol(EventName, Decl(templateLiteralTypes1.ts, 4, 53))
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 8, 15))
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 8, 15))

type EN1 = EventName<'Foo' | 'Bar' | 'Baz'>;
>EN1 : Symbol(EN1, Decl(templateLiteralTypes1.ts, 8, 49))
>EventName : Symbol(EventName, Decl(templateLiteralTypes1.ts, 4, 53))

type Loc = `${'top' | 'middle' | 'bottom'}-${'left' | 'center' | 'right'}`;
>Loc : Symbol(Loc, Decl(templateLiteralTypes1.ts, 9, 44))

// Primitive literal types can be spread into templates

type ToString<T extends string | number | boolean | bigint> = `${T}`;
>ToString : Symbol(ToString, Decl(templateLiteralTypes1.ts, 10, 75))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 14, 14))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 14, 14))

type TS1 = ToString<'abc' | 42 | true | -1234n>;
>TS1 : Symbol(TS1, Decl(templateLiteralTypes1.ts, 14, 69))
>ToString : Symbol(ToString, Decl(templateLiteralTypes1.ts, 10, 75))

// Casing modifiers

type Cases<T extends string> = `${uppercase T} ${lowercase T} ${capitalize T} ${uncapitalize T}`;
>Cases : Symbol(Cases, Decl(templateLiteralTypes1.ts, 15, 48))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 19, 11))

type TCA1 = Cases<'bar'>;  // 'BAR bar Bar bar'
type TCA2 = Cases<'BAR'>;  // 'BAR bar BAR bAR'

// Assignability

function test<T extends 'foo' | 'bar'>(name: `get${capitalize T}`) {
    let s1: string = name;
    let s2: 'getFoo' | 'getBar' = name;
}

function fa1<T>(x: T, y: { [P in keyof T]: T[P] }, z: { [P in keyof T & string as `p_${P}`]: T[P] }) {
    y = x;
    z = x;  // Error
}

function fa2<T, U extends T, A extends string, B extends A>(x: { [P in B as `p_${P}`]: T }, y: { [Q in A as `p_${Q}`]: U }) {
    x = y;
    y = x;  // Error
}

// String transformations using recursive conditional types

type Join<T extends unknown[], D extends string> =
    T extends [] ? '' :
    T extends [string | number | boolean | bigint] ? `${T[0]}` :
    T extends [string | number | boolean | bigint, ...infer U] ? `${T[0]}${D}${Join<U, D>}` :
    string;

type TJ1 = Join<[1, 2, 3, 4], '.'>
type TJ2 = Join<['foo', 'bar', 'baz'], '-'>;
type TJ3 = Join<[], '.'>

// Inference based on delimiters

type MatchPair<S extends string> = S extends `[${infer A},${infer B}]` ? [A, B] : unknown;

type T20 = MatchPair<'[1,2]'>;  // ['1', '2']
type T21 = MatchPair<'[foo,bar]'>;  // ['foo', 'bar']
type T22 = MatchPair<' [1,2]'>;  // unknown
type T23 = MatchPair<'[123]'>;  // unknown
type T24 = MatchPair<'[1,2,3,4]'>;  // ['1', '2,3,4']

type SnakeToCamelCase<S extends string> =
    S extends `${infer T}_${infer U}` ? `${lowercase T}${SnakeToPascalCase<U>}` :
    S extends `${infer T}` ? `${lowercase T}` :
    SnakeToPascalCase<S>;

type SnakeToPascalCase<S extends string> =
    string extends S ? string :
    S extends `${infer T}_${infer U}` ? `${capitalize `${lowercase T}`}${SnakeToPascalCase<U>}` :
    S extends `${infer T}` ? `${capitalize `${lowercase T}`}` :
>infer : Symbol(infer, Decl(templateLiteralTypes1.ts, 71, 17))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 71, 22))
>capitalize : Symbol(capitalize, Decl(templateLiteralTypes1.ts, 71, 32))

    never;

type RR0 = SnakeToPascalCase<'hello_world_foo'>;  // 'HelloWorldFoo'
>RR0 : Symbol(RR0, Decl(templateLiteralTypes1.ts, 72, 10))

type RR1 = SnakeToPascalCase<'FOO_BAR_BAZ'>;  // 'FooBarBaz'
>RR1 : Symbol(RR1, Decl(templateLiteralTypes1.ts, 74, 48))

type RR2 = SnakeToCamelCase<'hello_world_foo'>;  // 'helloWorldFoo'
>RR2 : Symbol(RR2, Decl(templateLiteralTypes1.ts, 75, 44))

type RR3 = SnakeToCamelCase<'FOO_BAR_BAZ'>;  // 'fooBarBaz'
>RR3 : Symbol(RR3, Decl(templateLiteralTypes1.ts, 76, 47))

// Single character inference

type FirstTwoAndRest<S extends string> = S extends `${infer A}${infer B}${infer R}` ? [`${A}${B}`, R] : unknown;
>FirstTwoAndRest : Symbol(FirstTwoAndRest, Decl(templateLiteralTypes1.ts, 77, 43))
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 81, 21))
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 81, 21))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 81, 59))
>B : Symbol(B, Decl(templateLiteralTypes1.ts, 81, 69))
>R : Symbol(R, Decl(templateLiteralTypes1.ts, 81, 79))
>A : Symbol(A, Decl(templateLiteralTypes1.ts, 81, 59))
>B : Symbol(B, Decl(templateLiteralTypes1.ts, 81, 69))
>R : Symbol(R, Decl(templateLiteralTypes1.ts, 81, 79))

type T25 = FirstTwoAndRest<'abcde'>;  // ['ab', 'cde']
>T25 : Symbol(T25, Decl(templateLiteralTypes1.ts, 81, 112))
>FirstTwoAndRest : Symbol(FirstTwoAndRest, Decl(templateLiteralTypes1.ts, 77, 43))

type T26 = FirstTwoAndRest<'ab'>;  // ['ab', '']
>T26 : Symbol(T26, Decl(templateLiteralTypes1.ts, 83, 36))
>FirstTwoAndRest : Symbol(FirstTwoAndRest, Decl(templateLiteralTypes1.ts, 77, 43))

type T27 = FirstTwoAndRest<'a'>;  // unknown
>T27 : Symbol(T27, Decl(templateLiteralTypes1.ts, 84, 33))
>FirstTwoAndRest : Symbol(FirstTwoAndRest, Decl(templateLiteralTypes1.ts, 77, 43))

type Capitalize<S extends string> = S extends `${infer H}${infer T}` ? `${uppercase H}${T}` : S;
>Capitalize : Symbol(Capitalize, Decl(templateLiteralTypes1.ts, 85, 32))
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 87, 16))
>S : Symbol(S, Decl(templateLiteralTypes1.ts, 87, 16))
>H : Symbol(H, Decl(templateLiteralTypes1.ts, 87, 54))
>T : Symbol(T, Decl(templateLiteralTypes1.ts, 87, 64))

type Uncapitalize<S extends string> = S extends `${infer H}${infer T}` ? `${lowercase H}${T}` : S;

type TC1 = Capitalize<'foo'>;  // 'Foo'
type TC2 = Uncapitalize<'Foo'>;  // 'foo'

type HexDigit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' |'8' | '9' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f';

type HexColor<S extends string> =
    S extends `#${infer R1}${infer R2}${infer G1}${infer G2}${infer B1}${infer B2}` ?
        [R1, R2, G1, G2, B1, B2] extends [HexDigit, HexDigit, HexDigit, HexDigit, HexDigit, HexDigit] ?
            S :
            never :
        never;

type TH1 = HexColor<'#8080FF'>;  // '#8080FF'
type TH2 = HexColor<'#80c0ff'>;  // '#80c0ff'
type TH3 = HexColor<'#8080F'>;  // never
type TH4 = HexColor<'#8080FFF'>;  // never

// Recursive inference

type Trim<S extends string> =
    S extends ` ${infer T}` ? Trim<T> :
    S extends `${infer T} ` ? Trim<T> :
    S;

type TR1 = Trim<'xx   '>;  // 'xx'
type TR2 = Trim<'   xx'>;  // 'xx'
type TR3 = Trim<'   xx   '>;  // 'xx'

type Split<S extends string, D extends string> =
    string extends S ? string[] :
    S extends '' ? [] :
    S extends `${infer T}${D}${infer U}` ? [T, ...Split<U, D>] :
    [S];

type T40 = Split<'foo', '.'>;  // ['foo']
type T41 = Split<'foo.bar.baz', '.'>;  // ['foo', 'bar', 'baz']
type T42 = Split<'foo.bar', ''>;  // ['f', 'o', 'o', '.', 'b', 'a', 'r']
type T43 = Split<any, '.'>;  // string[]

// Inference and property name paths

declare function getProp<T, P0 extends keyof T & string, P1 extends keyof T[P0] & string, P2 extends keyof T[P0][P1] & string>(obj: T, path: `${P0}.${P1}.${P2}`): T[P0][P1][P2];
declare function getProp<T, P0 extends keyof T & string, P1 extends keyof T[P0] & string>(obj: T, path: `${P0}.${P1}`): T[P0][P1];
declare function getProp<T, P0 extends keyof T & string>(obj: T, path: P0): T[P0];
declare function getProp(obj: object, path: string): unknown;

let p1 = getProp({ a: { b: {c: 42, d: 'hello' }}} as const, 'a');
let p2 = getProp({ a: { b: {c: 42, d: 'hello' }}} as const, 'a.b');
let p3 = getProp({ a: { b: {c: 42, d: 'hello' }}} as const, 'a.b.d');

type PropType<T, Path extends string> =
    string extends Path ? unknown :
    Path extends keyof T ? T[Path] :
    Path extends `${infer K}.${infer R}` ? K extends keyof T ? PropType<T[K], R> : unknown :
    unknown;

declare function getPropValue<T, P extends string>(obj: T, path: P): PropType<T, P>;
declare const s: string;

const obj = { a: { b: {c: 42, d: 'hello' }}};

getPropValue(obj, 'a');  // { b: {c: number, d: string } }
getPropValue(obj, 'a.b');  // {c: number, d: string }
getPropValue(obj, 'a.b.d');  // string
getPropValue(obj, 'a.b.x');  // unknown
getPropValue(obj, s);  // unknown

// Infer type variables in template literals have string constraint

type S1<T> = T extends `foo${infer U}bar` ? S2<U> : never;
type S2<S extends string> = S;

// Check that infer T declarations are validated

type TV1 = `${infer X}`;

// Batched single character inferences for lower recursion depth

type Chars<S extends string> =
    string extends S ? string[] :
    S extends `${infer C0}${infer C1}${infer C2}${infer C3}${infer C4}${infer C5}${infer C6}${infer C7}${infer C8}${infer C9}${infer R}` ? [C0, C1, C2, C3, C4, C5, C6, C7, C8, C9, ...Chars<R>] :
    S extends `${infer C}${infer R}` ? [C, ...Chars<R>] :
    S extends '' ? [] :
    never;

type L1 = Chars<'FooBarBazThisIsALongerString'>;  // ['F', 'o', 'o', 'B', 'a', 'r', ...]

// Infer never when source isn't a literal type that matches the pattern

type Foo<T> = T extends `*${infer S}*` ? S : never;

type TF1 = Foo<any>;      // never
type TF2 = Foo<string>;   // never
type TF3 = Foo<'abc'>;    // never
type TF4 = Foo<'*abc*'>;  // 'abc'

// Cross product unions limited to 100,000 constituents

type A = any;

type U1 = {a1:A} | {b1:A} | {c1:A} | {d1:A} | {e1:A} | {f1:A} | {g1:A} | {h1:A} | {i1:A} | {j1:A};
type U2 = {a2:A} | {b2:A} | {c2:A} | {d2:A} | {e2:A} | {f2:A} | {g2:A} | {h2:A} | {i2:A} | {j2:A};
type U3 = {a3:A} | {b3:A} | {c3:A} | {d3:A} | {e3:A} | {f3:A} | {g3:A} | {h3:A} | {i3:A} | {j3:A};
type U4 = {a4:A} | {b4:A} | {c4:A} | {d4:A} | {e4:A} | {f4:A} | {g4:A} | {h4:A} | {i4:A} | {j4:A};
type U5 = {a5:A} | {b5:A} | {c5:A} | {d5:A} | {e5:A} | {f5:A} | {g5:A} | {h5:A} | {i5:A} | {j5:A};

type U100000 = U1 & U2 & U3 & U4 & U5;  // Error

type Digits = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;

type D100000 = `${Digits}${Digits}${Digits}${Digits}${Digits}`;  // Error

type TDigits = [0] | [1] | [2] | [3] | [4] | [5] | [6] | [7] | [8] | [9];

type T100000 = [...TDigits, ...TDigits, ...TDigits, ...TDigits, ...TDigits];  // Error

